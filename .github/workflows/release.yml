name: Release

on:
  push:
    tags:
      - 'v*.*.*'

permissions:
  contents: write

jobs:
  release:
    name: Build and Publish Release
    runs-on: macos-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract version info
        id: version
        run: |
          TAG=${GITHUB_REF#refs/tags/}
          VERSION=${TAG#v}
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Release Tag: $TAG"
          echo "ğŸ“¦ App Version: $VERSION"

      - name: Set up code signing keychain
        env:
          CERTIFICATE_P12: ${{ secrets.CERTIFICATE_P12 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
        run: |
          KEYCHAIN_PASSWORD="build-keychain-pass"
          KEYCHAIN_PATH="build.keychain"

          echo "ğŸ” Setting up code signing keychain..."

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings "$KEYCHAIN_PATH"

          # Import certificate
          echo "$CERTIFICATE_P12" | base64 --decode > certificate.p12
          security import certificate.p12 \
            -k "$KEYCHAIN_PATH" \
            -P "$CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/productsign

          # Remove the default reconfirm timeout
          security set-key-partition-list \
            -S apple-tool:,apple:,codesign:,productsign: \
            -s \
            -k "$KEYCHAIN_PASSWORD" \
            "$KEYCHAIN_PATH" 2>&1 | head -1

          # Verify certificate
          CERT_NAME="${{ secrets.CERTIFICATE_NAME }}"
          if security find-certificate -c "$CERT_NAME" "$KEYCHAIN_PATH"; then
            echo "âœ… Certificate imported: $CERT_NAME"
          else
            echo "âš ï¸  Certificate not found, continuing anyway..."
          fi

          # Clean up
          rm -f certificate.p12

          # Set environment variables for xcodebuild
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV
          echo "CODE_SIGN_IDENTITY=$CERT_NAME" >> $GITHUB_ENV

      - name: Build application
        env:
          CODE_SIGN_IDENTITY: ${{ secrets.CERTIFICATE_NAME }}
          KEYCHAIN_PATH: build.keychain
        run: |
          echo "ğŸ”¨ Building Notimanager..."
          VERSION="${{ steps.version.outputs.version }}"

          # Build archive
          xcodebuild -project Notimanager.xcodeproj \
            -scheme Notimanager \
            -configuration Release \
            -archivePath "build/Notimanager.xcarchive" \
            CODE_SIGN_IDENTITY="$CODE_SIGN_IDENTITY" \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="" \
            archive

          echo "âœ… Archive created"

          # Export app
          xcodebuild -exportArchive \
            -archivePath "build/Notimanager.xcarchive" \
            -exportPath "build/release" \
            -exportOptionsPlist scripts/ExportOptions.plist

          echo "âœ… App exported"

          # Verify code signing
          if [ -d "build/release/Notimanager.app" ]; then
            codesign -dv "build/release/Notimanager.app" 2>&1 || true
            echo "âœ… App signed successfully"
          else
            echo "âŒ App not found after build"
            exit 1
          fi

      - name: Create DMG
        run: |
          echo "ğŸ“¦ Creating DMG..."

          # Install create-dmg
          npm install --global create-dmg

          # Get version from app
          VERSION="${{ steps.version.outputs.version }}"
          APP_PATH="build/release/Notimanager.app"

          # Create DMG
          create-dmg \
            --no-code-sign \
            "$APP_PATH" \
            build/

          # Find created DMG
          DMG_PATH=$(find build -name "Notimanager*.dmg" -maxdepth 1 | head -1)

          if [ -z "$DMG_PATH" ]; then
            echo "âŒ DMG not found"
            exit 1
          fi

          # Rename to consistent naming
          mv "$DMG_PATH" "build/Notimanager-${VERSION}.dmg"
          DMG_PATH="build/Notimanager-${VERSION}.dmg"

          # Get file size
          DMG_SIZE=$(stat -f%z "$DMG_PATH" 2>/dev/null || stat -c%s "$DMG_PATH" 2>/dev/null)

          echo "âœ… DMG created: $DMG_PATH"
          echo "ğŸ“Š Size: $DMG_SIZE bytes"

          echo "DMG_PATH=$DMG_PATH" >> $GITHUB_ENV
          echo "DMG_SIZE=$DMG_SIZE" >> $GITHUB_ENV

      - name: Sign DMG with Sparkle
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          if [ -z "$SPARKLE_PRIVATE_KEY" ]; then
            echo "âš ï¸  SPARKLE_PRIVATE_KEY not set, skipping Sparkle signature"
            echo "SPARKLE_SIGNATURE=placeholder" >> $GITHUB_ENV
            exit 0
          fi

          echo "ğŸ” Signing DMG with Sparkle..."

          # Import private key
          echo "$SPARKLE_PRIVATE_KEY" > private_key.pem

          # Sign the DMG
          if [ -f "bin/sign_update" ]; then
            SIGNATURE=$(./bin/sign_update --ed-key-file private_key.pem "${{ env.DMG_PATH }}")
            echo "âœ… DMG signed"
            echo "SPARKLE_SIGNATURE=$SIGNATURE" >> $GITHUB_ENV
          else
            echo "âš ï¸  sign_update tool not found"
            echo "SPARKLE_SIGNATURE=placeholder" >> $GITHUB_ENV
          fi

          rm -f private_key.pem

      - name: Update Appcast
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SPARKLE_SIGNATURE: ${{ env.SPARKLE_SIGNATURE }}
          DMG_SIZE: ${{ env.DMG_SIZE }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"

          mkdir -p updates

          # 1. Download EXISTING appcast.xml to preserve history
          echo "â¬‡ï¸ Downloading existing appcast from previous release..."
          if gh release download -p appcast.xml -D updates 2>/dev/null; then
            echo "âœ… Downloaded existing appcast.xml"
          else
            echo "ğŸ“ No existing appcast found, creating new one..."
            echo '<?xml version="1.0" encoding="UTF-8"?>' > updates/appcast.xml
            echo '<rss xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" version="2.0">' >> updates/appcast.xml
            echo '    <channel>' >> updates/appcast.xml
            echo '        <title>Notimanager</title>' >> updates/appcast.xml
            echo '    </channel>' >> updates/appcast.xml
            echo '</rss>' >> updates/appcast.xml
          fi

          # 2. Run Python script to APPEND the new version entry
          echo "ğŸ“‹ Appending new version ${VERSION} to appcast..."

          python3 scripts/generate_appcast_from_changelog.py \
            --changelog docs/CHANGELOG.md \
            --appcast updates/appcast.xml \
            --version "$VERSION" \
            --url "https://github.com/abd3lraouf/Notimanager/releases/download/${TAG}/Notimanager-${VERSION}.dmg" \
            --signature "$SPARKLE_SIGNATURE" \
            --length "$DMG_SIZE"

          echo ""
          echo "ğŸ“‹ Appcast preview (first 50 lines):"
          head -50 updates/appcast.xml

      - name: Generate changelog
        id: changelog
        run: |
          echo "ğŸ“‹ Generating changelog..."
          VERSION="${{ steps.version.outputs.version }}"

          # Extract current version only from CHANGELOG.md
          if [ -f "docs/CHANGELOG.md" ]; then
            awk "/^## \[$VERSION\]/{flag=1; next} /^## \[/{if(!/^## \[$VERSION\]/) flag=0} flag" docs/CHANGELOG.md > release_notes_current.md 2>/dev/null || true

            if [ -s release_notes_current.md ]; then
              echo "âœ… Changelog extracted for $VERSION"
              echo "ğŸ“‹ Release Notes:"
              cat release_notes_current.md
            else
              echo "âš ï¸  No entry found for $VERSION in CHANGELOG.md, using git log..."
              git log --pretty=format:"- %s" $(git describe --tags --abbrev=0 HEAD^)..HEAD > release_notes_current.md
            fi
          else
            echo "ğŸ“ No CHANGELOG.md found, generating from git log..."
            git log --pretty=format:"- %s" $(git describe --tags --abbrev=0 HEAD^)..HEAD > release_notes_current.md
          fi

          # Create full release notes for GitHub Release
          cat > release_notes_full.md << EOF
          For installation instructions and documentation, please see [the README](https://github.com/abd3lraouf/Notimanager#readme).

          **Note:** This release is signed with a self-signed certificate for CI/CD automation.
          On first launch, you may need to right-click the app and select "Open".

          ---

          EOF

          cat release_notes_current.md >> release_notes_full.md

          # Add full changelog link
          cat >> release_notes_full.md << 'EOF'

          ---
          **Full Changelog**: https://github.com/abd3lraouf/Notimanager/compare/$PREV_TAG...v$VERSION
          EOF

          # Add previous tag for comparison link
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          if [ -n "$PREV_TAG" ]; then
            sed -i '' "s/\$PREV_TAG/$PREV_TAG/g" release_notes_full.md
          else
            sed -i '' 's/\$PREV_TAG/v0.0.0/g' release_notes_full.md
          fi

          sed -i '' "s/\$VERSION/$VERSION/g" release_notes_full.md

          echo "ğŸ“‹ GitHub Release Notes:"
          cat release_notes_full.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: Notimanager ${{ steps.version.outputs.version }}
          body_path: release_notes_full.md
          files: |
            ${{ env.DMG_PATH }}
            updates/appcast.xml
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release summary
        run: |
          echo "ğŸ‰ Release created successfully!"
          echo ""
          echo "ğŸ“¦ Version: ${{ steps.version.outputs.version }}"
          echo "ğŸ“ DMG: ${{ env.DMG_PATH }}"
          echo "ğŸ“Š Size: ${{ env.DMG_SIZE }} bytes"
          echo ""
          echo "ğŸ” Code signing: Self-signed (CI certificate)"
          echo "ğŸ“‹ Release: https://github.com/abd3lraouf/Notimanager/releases/tag/${{ steps.version.outputs.tag }}"
